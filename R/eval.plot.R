#####################################################
#########	 PLOT OPTIMIZATION CRITERIA #############
#####################################################

#' @title Generate Basic Plot for ENMevaluate Output
#' @description This function can be used to generate a basic plot of evaluation metrics generated by a call of \code{\link{ENMevaluate}}.
#' @usage eval.plot(results, value = "delta.AICc", variance = NULL, legend = TRUE, legend.position = "topright")
#' @param results A data.frame of results from \code{\link{ENMevaluate}}.
#' @param value Character string of the column of \code{results} to use for plotting.
#' @param variance Character string of the column of \code{results} to be used for error bars.
#' @param legend Logical; If `TRUE` (default), includes legend in plot with fc's.
#' @param legend.position Character string for the placement of the legend.
#' @author Robert Muscarella <bob.muscarella@gmail.com>
#' @examples 
#' data(enmeval_results)
#' 
#' par(mfrow=c(2,2))
#' eval.plot(enmeval_results@results, legend.position="topright")
#' eval.plot(enmeval_results@results, "Mean.AUC", )
#' eval.plot(enmeval_results@results, "Mean.AUC.DIFF", variance="Var.AUC.DIFF")
#' eval.plot(enmeval_results@results, "Mean.ORmin")

#' @export
eval.plot <- function(results, value="delta.AICc", variance=NULL, legend=TRUE, legend.position="topright") {
	res <- results
	if(!class(res)=='data.frame') {
			stop("check input - eval.plot requires results table as data.frame", call.=F)
		}
	if(sum(value %in% colnames(res))==0) {
			stop("value not in results table provided", call.=F)
		}
	fc <- length(unique(res$fc))
	col <- rainbow(fc)
	rm <- length(unique(res$rm))
	xlab <- "Regularization Multiplier"

	y <- res[,value]
	ylim <- c(min(y, na.rm=TRUE), max(y, na.rm=TRUE))

	if(!is.null(variance)){
		if(!variance %in% colnames(res)){
			stop("Check name of variance column")
			}
		v <- res[,variance]
		ylim <- c(min(y-v), max(y+v))
		}

	par(mar=c(4.5,4.5,1,1))
	plot(res$rm, y, col='white', ylim=ylim, ylab=value, xlab=xlab, axes=F, cex.lab=1.5)
	if(value=="delta.AICc") abline(h=2, lty=3)
	axis(1, at= unique(res$rm))
	axis(2)
	box()
	for (j in 1:length(unique(res$fc))){
		s <- ((fc*rm)-fc+j)
		points(res$rm[seq(j, s, fc)], y[seq(j, s, fc)], type="l", col=col[j])
		if(!is.null(variance)){
			arrows(res$rm[seq(j, s, fc)], 
				y[seq(j, s, fc)] + v[seq(j, s, fc)], 
				res$rm[seq(j, s, fc)], 
				y[seq(j, s, fc)] - v[seq(j, s, fc)],
				code=3, length=.05, angle=90, col=col[j])
		}
	}
	points(res$rm, y, bg=col, pch=21)

	if(legend==TRUE){
	legend(legend.position, legend=unique(res$fc), pt.bg=col, pch=21, bg='white')
	}
}
